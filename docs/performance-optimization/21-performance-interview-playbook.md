# 2026-02-14 성능 면접 통합 플레이북

이 문서는 기존의 성능 면접 자료 3개를 하나로 통합한 버전입니다.

- 일반 Q&A (설명형)
- 압박 Q&A (반박형)
- 25분 모의면접 진행 가이드

## 1) 25분 실전 진행 방식

- 1분: 20초 자기소개 + 40초 성능 사례
- 10분: 기본 질문 5개
- 10분: 압박 질문 5개
- 4분: 피드백 반영 후 재답변

### 준비 문서

- 기본 스크립트: `docs/performance-optimization/20-performance-story-script.md`
- Redis 스크립트: `docs/performance-optimization/07-redis-adoption-story-script.md`
- MySQL 검증: `docs/performance-optimization/02-mysql-validation-report.md`
- 코드/테스트 매핑: `docs/performance-optimization/22-code-test-evidence-map.md`

## 2) 기본 질문 세트 (설명형)

### Q1. 이번 프로젝트에서 성능 병목을 어떻게 찾았나요?

- 10초 답변:
  감으로 최적화하지 않고, 같은 시나리오에서 쿼리 수와 응답 시간을 먼저 측정해 병목 구간을 찾았습니다.
- 30초 답변:
  사용자 체감이 큰 알림장 목록과 대시보드 통계를 우선 대상으로 잡았습니다.
  동일 데이터/동일 시나리오에서 전후 비교가 가능하도록 테스트를 만들고,
  쿼리 수와 elapsed time을 같이 기록해서 N+1과 불필요한 집계 경로를 병목으로 확정했습니다.

### Q2. 왜 Notepad를 첫 개선 대상으로 선택했나요?

- 10초 답변:
  목록 조회는 호출 빈도가 높고, N+1이 있으면 데이터가 늘수록 가장 빠르게 느려지기 때문입니다.
- 30초 답변:
  알림장은 학부모/교사가 반복적으로 조회하는 핵심 화면이라 성능 체감이 바로 나타납니다.
  실제로 읽음 수를 건별 조회하는 구조가 있어서 페이지 크기에 비례해 쿼리가 증가했고,
  투자 대비 효과가 가장 큰 구간이라 1순위로 선정했습니다.

### Q3. Notepad N+1은 어떻게 해결했나요?

- 10초 답변:
  건별 읽음 조회를 없애고, 페이지 notepad ID를 모아 집계 쿼리 1회로 readCount를 계산했습니다.
- 30초 답변:
  기존엔 페이지 N건에 대해 `findReadConfirmsByNotepadId`를 반복 호출했습니다.
  이를 `countReadConfirmsByNotepadIds` 집계 쿼리로 전환하고,
  서비스에서 ID별 맵으로 매핑해 DTO를 구성했습니다.
  결과적으로 쿼리 수가 22에서 4로 줄었습니다.

### Q4. 대시보드 통계는 어떤 방식으로 개선했나요?

- 10초 답변:
  목록 로딩 후 계산하던 경로를 집계 쿼리 중심으로 바꿨습니다.
- 30초 답변:
  출석률은 PRESENT/LATE를 각각 count하던 구조를 단일 집계로 통합했고,
  공지 열람률도 공지 목록을 읽어 합산하는 대신 DB에서 `SUM(view_count)`로 계산했습니다.
  계산 경로를 단순화해 쿼리 수 13 -> 10, 응답 시간 14ms -> 2ms를 확인했습니다.

### Q5. 인덱스는 어떤 기준으로 설계했나요?

- 10초 답변:
  실제 `where/order/join` 패턴에 맞춘 복합 인덱스를 설계하고 EXPLAIN으로 검증했습니다.
- 30초 답변:
  코드의 JPQL/SQL 패턴을 먼저 확인한 뒤,
  Notepad/Announcement 목록 정렬, Dashboard 집계 조건에 맞춰 복합 인덱스를 추가했습니다.
  EXPLAIN에서 ALL/filesort가 줄고 ref/range로 전환되는 것을 확인했습니다.

### Q6. Redis refresh token 경로를 왜 바꿨나요?

- 10초 답변:
  패턴 키 검색은 운영에서 부담이 커서, `refresh:{email}` 단일 키 O(1) 조회/삭제로 바꿨습니다.
- 30초 답변:
  기존 패턴 검색 방식은 키 수 증가 시 비용과 운영 리스크가 커집니다.
  그래서 키 설계를 단순화해 조회/삭제를 예측 가능한 O(1)로 만들고,
  재발급 시 Redis 저장 토큰과 요청 토큰의 일치 검증까지 추가해 안전성과 성능을 같이 챙겼습니다.

## 3) 압박 질문 세트 (반박형)

### Q1. "측정값이 너무 작습니다. 15ms, 4ms가 의미 있나요?"

- 피해야 할 답변:
  그래도 빨라졌으니까 의미 있습니다.
- 권장 답변:
  절대값보다 동일 조건에서의 상대 개선을 먼저 봤습니다.
  특히 Notepad는 쿼리 수가 22 -> 4로 줄어 구조적 개선이 명확합니다.
  다음 단계로는 k6로 동시성 부하를 주고 p95/p99까지 확장 검증할 계획입니다.

### Q2. "테스트 DB가 H2인데 MySQL 성능을 대표할 수 있나요?"

- 피해야 할 답변:
  크게 다르지 않을 것 같습니다.
- 권장 답변:
  맞습니다. H2 수치는 절대 성능 지표라기보다 회귀 감지용입니다.
  그래서 MySQL에서 EXPLAIN 전/후를 별도로 확인했고,
  실행계획이 ALL/filesort에서 ref/range로 바뀐 점과 slow query 추이를 근거로 제시했습니다.

### Q3. "캐시를 먼저 쓰면 더 빨랐을 텐데 왜 안 했나요?"

- 피해야 할 답변:
  캐시는 복잡해서 미뤘습니다.
- 권장 답변:
  캐시는 증상 완화이고, N+1은 원인 제거라 우선순위를 원인 해결에 뒀습니다.
  기본 비용을 낮춘 뒤 캐시를 붙여야 캐시 미스 상황에서도 성능이 안정적입니다.

### Q4. "인덱스 많이 추가하면 쓰기 성능 떨어지는데 괜찮나요?"

- 피해야 할 답변:
  지금은 괜찮아서 문제 없습니다.
- 권장 답변:
  맞습니다. 인덱스는 쓰기/저장공간 비용이 증가합니다.
  이 프로젝트는 조회 중심 트래픽이라 read 최적화를 우선했고,
  이후 slow query log 기준으로 인덱스 효율을 주기적으로 재평가할 계획입니다.

### Q5. "쿼리 수만 줄였지 실제 사용자 경험은 개선됐나요?"

- 피해야 할 답변:
  쿼리 수가 줄면 당연히 좋아집니다.
- 권장 답변:
  쿼리 수만 보지 않고 elapsed time도 같이 측정했습니다.
  Notepad는 15ms -> 4ms, Dashboard는 14ms -> 2ms로 개선됐고,
  다음 단계는 프론트 체감 지표(TTFB, 페이지 전환 시간)까지 연결할 예정입니다.

### Q6. "Redis refresh 키를 email 단일 키로 바꾼 근거가 약하지 않나요?"

- 피해야 할 답변:
  코드가 단순해져서요.
- 권장 답변:
  핵심은 패턴 검색 제거입니다.
  `refresh:{email}`로 조회/삭제를 O(1)로 만들어 운영 중 키 스캔 리스크를 낮췄고,
  토큰 일치 검증까지 추가해 안전성도 강화했습니다.

## 4) 답변 점검 체크리스트

- 숫자를 먼저 말했는가? (예: 22 -> 4)
- 원인을 한 줄로 설명했는가? (예: readCount N+1)
- 해결 방법이 구체적인가? (집계 쿼리/인덱스/실행계획)
- 검증 근거를 제시했는가? (테스트 로그/EXPLAIN)
- 트레이드오프를 인정했는가?

## 5) 자주 하는 실수

- "빨라졌습니다"만 반복하고 수치를 말하지 않음
- 캐시, 인덱스, 쿼리 개선 순서를 설명하지 못함
- 왜 이 작업부터 했는지 우선순위 근거가 없음
- 한계/리스크 질문에 방어적으로만 답함

## 6) 마무리 한 문장 템플릿

"저는 기능 구현 이후 성능 병목을 수치로 검증하고,
조회 경로와 실행계획을 함께 개선해 재현 가능한 성능 향상을 만드는 방식으로 개발합니다."
