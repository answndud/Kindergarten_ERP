# 2026-02-14 Redis 도입 성능 개선 스크립트 (면접/포트폴리오용)

## 15초 한 줄 소개

"JWT 기반 인증에서 매 요청마다 DB를 타던 구조를 Redis 기반 토큰 검증으로 전환해,
인증 경로 지연과 DB 부하를 줄이고, 운영 이슈(키 설계/TTL/직렬화 오류)까지 해결한 경험이 있습니다."

## 20초 오프닝 (면접 첫 답변)

유치원 ERP에서 초기에는 인증/세션성 조회를 RDB 중심으로 처리했습니다.
기능은 동작했지만 사용자 수가 늘수록 로그인/재발급/로그아웃 경로가 비싸졌고,
그래서 Redis를 "무작정 캐시"가 아니라 "명확한 병목 제거" 목적으로 도입했습니다.
도입 과정에서 TTL 누락, 키 충돌, 직렬화 오류를 겪었고,
키 네이밍 규칙과 만료 정책, 저장 포맷을 정리해 안정적으로 운영 가능한 구조로 개선했습니다.

## 도입 전 상황 (가정 시나리오)

### 시스템 조건

- 인증 방식: Access Token(짧은 만료) + Refresh Token(긴 만료)
- 초기 저장소: Refresh Token을 MySQL 테이블에 저장/조회
- 트래픽 특성: 출근 시간대(08:30~09:30) 교사/학부모 동시 로그인 피크

### 도입 전 문제

1. **DB 집중 부하**
   - 토큰 재발급 시 `email + token + expiresAt` 조회가 반복되며 DB read QPS 급증
   - API는 빨라도 인증 경로가 병목이 되어 전체 체감 성능 저하

2. **불필요한 디스크 I/O**
   - 토큰은 본질적으로 "짧은 수명 + 빠른 조회/삭제" 데이터인데 영속 테이블에 저장
   - 로그아웃/재로그인 빈도가 높은 계정일수록 write/read churn 증가

3. **만료 데이터 정리 복잡도**
   - 만료 토큰 정리를 배치/쿼리로 처리해야 해서 운영 포인트 증가
   - 정리 타이밍에 따라 조회 결과가 불안정해질 여지 존재

## 왜 Redis를 고려했는지 (의사결정 근거)

### 요구사항 매핑

- 필요한 특성: 낮은 지연, 단일 키 O(1) 조회, TTL 자동 만료, 빠른 삭제
- Redis 적합성: 인메모리 기반 + 만료 정책 내장 + 키 기반 조회 최적

### 기술 선택 이유

- "모든 것을 캐시"가 아니라, **토큰이라는 휘발성 도메인에 한정**해 도입 범위를 통제
- RDB 책임(정합성 핵심 데이터)과 Redis 책임(세션/토큰성 데이터)을 분리해 운영 단순화
- 장애 시 폴백 전략(재로그인 유도/짧은 Access TTL)을 설계 가능

## 도입하면서 겪은 실제 이슈(가정)와 해결

### 이슈 1) 키 설계 실패: 패턴 검색 기반 조회

초기에는 `refresh:*:{email}` 형태로 저장해 `KEYS`/패턴 검색에 의존했습니다.
개발 환경에서는 문제 없어 보였지만, 키 수가 늘자 조회 지연과 Redis CPU 스파이크가 발생했습니다.

**원인**
- 단건 조회 시에도 패턴 탐색이 필요해 O(N) 성격 발생
- 운영에서 `KEYS`는 블로킹 위험이 큼

**해결**
- 키를 `refresh:{email}` 단일 규칙으로 통일
- 조회/삭제를 모두 단일 키 GET/DEL로 전환(O(1))

---

### 이슈 2) TTL 누락: "영원히 살아있는" 토큰

처음 마이그레이션 시 일부 코드 경로에서 `set`만 호출하고 만료시간을 지정하지 않아,
만료되어야 할 refresh token이 Redis에 남는 문제가 발생했습니다.

**증상**
- 기대보다 많은 키 누적
- 일부 계정에서 로그아웃 후 재발급 정책이 꼬이는 현상

**해결**
- 토큰 저장 API를 단일 메서드로 강제(`set + TTL` 원자적 보장)
- TTL 단위(초/밀리초) 혼동 방지를 위해 `Duration` 기반 인터페이스로 변경
- 통합 테스트에 "저장 직후 TTL 존재" 검증 케이스 추가

---

### 이슈 3) 직렬화/역직렬화 오류

RedisTemplate 설정이 기본 JDK 직렬화로 남아 있고,
다른 경로는 문자열(JSON) 기반으로 읽으면서 `ClassCastException`/파싱 오류가 발생했습니다.

**원인**
- 저장 포맷이 경로마다 달라 "같은 키, 다른 타입" 상태 발생

**해결**
- 토큰 값은 단순 문자열로 통일(불필요한 객체 직렬화 제거)
- `StringRedisTemplate` 중심으로 인증 경로 단순화
- 네이밍/포맷/TTL을 문서화해 신규 코드가 같은 규칙을 따르도록 가드

---

### 이슈 4) 다중 로그인 정책 충돌

"한 이메일 1개 refresh token" 정책인데, 동시 로그인 시 최신 토큰으로 교체되는 타이밍에
기존 단말이 재발급을 시도하면 실패하는 케이스가 발생했습니다.

**해결**
- 정책을 명확히 정의: "최신 로그인 우선" (single-session)
- 클라이언트 에러 메시지를 표준화해 재로그인 유도 UX 일관화
- 필요 시 멀티 디바이스 정책으로 확장 가능한 키 구조(`refresh:{email}:{deviceId}`)를 후속안으로 준비

## 개선 결과 (가정 수치, 동일 시나리오 비교)

측정 시나리오: "로그인 후 15분 내 만료된 Access로 재발급 1회"를 1,000회 반복

- 토큰 재발급 API 평균 응답시간: **32ms -> 9ms**
- 토큰 재발급 API p95: **78ms -> 21ms**
- 인증 경로 DB 조회 수(시나리오당): **2회 -> 0회**
- 피크 시간대 MySQL CPU: **최대 71% -> 52%**
- Redis 메모리 사용량: 증가(의도된 비용), 대신 DB 부하와 지연을 안정적으로 절감

## 1분 버전 (실전 답변)

처음에는 refresh token을 MySQL에 저장해 기능 자체는 문제없이 동작했습니다.
하지만 로그인 피크 구간에서 재발급 요청이 몰리면 인증 경로가 DB 병목이 되었고,
그래서 토큰 데이터의 특성(짧은 수명, 단건 조회, 빠른 삭제)에 맞춰 Redis를 도입했습니다.

도입 초반에는 키를 패턴 검색으로 설계해 조회가 비효율적이었고,
TTL 누락으로 만료 토큰이 남거나, 직렬화 포맷 불일치로 예외가 터지는 문제도 있었습니다.
이를 키 단일화(`refresh:{email}`), 저장 API 단일화(`set + TTL`),
문자열 포맷 통일(`StringRedisTemplate`)로 정리했습니다.

그 결과 동일 시나리오 기준 재발급 API 평균 응답시간은 32ms에서 9ms,
p95는 78ms에서 21ms로 줄었고, 인증 경로의 DB 조회를 제거해 피크 시간대 DB CPU도 낮췄습니다.
핵심은 Redis를 "붙였다"가 아니라,
운영 이슈를 통해 키/만료/포맷 규칙을 팀 표준으로 만든 경험입니다.

## 3분 버전 (깊이 질문 대응)

### 1) 어떤 기준으로 Redis 도입 여부를 판단했나

"느리다"는 감이 아니라, 인증 경로에 대해
동일 시나리오에서 응답시간(p50/p95)과 DB 조회 수를 측정했습니다.
그 결과 병목이 비즈니스 쿼리가 아니라 토큰 검증/재발급 경로에 있다는 점을 확인했고,
도메인 특성상 Redis가 구조적으로 맞는 선택이라고 판단했습니다.

### 2) 왜 가장 먼저 키 설계를 고쳤나

Redis 성능 이슈의 상당수는 자료구조보다 키 설계에서 시작됩니다.
패턴 검색 의존을 제거하고 단일 키 조회로 바꾸는 것이,
코드 변경 대비 체감 효과가 가장 큰 "저위험 고효율" 개선이었습니다.

### 3) 가장 어려웠던 점은 무엇이었나

개발 환경에서는 재현되지 않던 TTL/직렬화 문제가
통합 시나리오에서만 간헐적으로 나타난 점이 가장 어려웠습니다.
그래서 기능 테스트 외에 "키 존재/TTL/삭제/재발급" 흐름을 끝까지 검증하는
통합 테스트를 추가해 회귀를 막았습니다.

### 4) 트레이드오프는 어떻게 관리했나

Redis 도입은 인프라 복잡도와 운영 포인트를 늘립니다.
대신 인증 경로 지연과 DB 부하를 안정적으로 줄일 수 있습니다.
저는 키 규칙, TTL 정책, 장애 시 동작(재로그인 유도)을 문서화해
복잡도 상승을 운영 표준으로 상쇄했습니다.

## 자주 나오는 꼬리 질문 템플릿

### Q1. DB 인덱스 튜닝으로 충분하지 않았나요?

인덱스 튜닝은 필요하지만, 토큰은 원래 TTL 기반 휘발성 데이터라
RDB에 두는 것 자체가 구조적으로 비효율적이었습니다.
즉, "쿼리를 빠르게"보다 "저장소 역할을 맞게"가 핵심이었습니다.

### Q2. Redis 장애 시 인증은 어떻게 되나요?

Refresh 재발급은 실패 처리하고 재로그인을 유도합니다.
Access TTL을 짧게 유지해 보안 리스크를 제한하고,
장애 복구 후 정상 플로우로 복귀하도록 설계했습니다.

### Q3. 도입 후 가장 큰 배움은?

캐시/인메모리 기술의 성패는 코드 한 줄보다
키 설계, TTL 정책, 직렬화 표준 같은 운영 규칙에 달려 있다는 점입니다.

## 포트폴리오에서 강조할 포인트

- 단순 "Redis 사용"이 아니라 **병목 측정 -> 가설 -> 도입 -> 장애/오류 해결 -> 재측정**의 전체 사이클
- 성능 수치뿐 아니라 운영 안정성(키 규칙, TTL, 예외 처리)까지 개선했다는 점
- 기술 선택의 이유를 도메인 특성과 트래픽 패턴으로 설명한 점

## 한 줄 결론

"Redis를 도입해 빨라졌다"가 아니라,
"인증 도메인에 맞는 저장소 분리와 운영 규칙 정립으로 성능과 안정성을 함께 확보했다"가 이 경험의 핵심입니다.

## 부록 A. 기술면접형 답변 (정량/구조 중심)

### 30초 버전

초기에는 refresh token을 MySQL에서 조회/검증해 재발급 경로가 DB read 병목이었습니다.
Redis 도입 시 `refresh:{email}` 단일 키로 조회/삭제를 O(1)로 단순화하고,
저장 API를 `set + TTL`로 통합해 만료 누락을 제거했습니다.
또한 문자열 포맷으로 직렬화 규칙을 통일해 캐스팅 오류를 없앴습니다.
동일 시나리오 기준 재발급 평균 32ms에서 9ms, p95 78ms에서 21ms로 개선했습니다.

### 1분 버전

의사결정 기준은 두 가지였습니다. 첫째, 데이터 특성입니다.
Refresh token은 짧은 수명, 단건 조회/삭제 중심이라 RDB보다 TTL 내장 KV 저장소가 적합했습니다.
둘째, 계측 결과입니다. 동일 시나리오에서 인증 경로 DB 조회가 반복되어
피크 시간대에 지연이 커지는 것을 확인했습니다.

도입 과정에서 네 가지 이슈를 해결했습니다.
1) 패턴 검색 키 설계로 인한 비효율을 `refresh:{email}` 단일 키로 개선,
2) TTL 누락을 저장 메서드 단일화로 차단,
3) JDK 직렬화/문자열 혼재 문제를 `StringRedisTemplate`로 통일,
4) 동시 로그인 정책 충돌을 single-session 정책으로 명시했습니다.

결과적으로 재발급 API 평균/상위지연이 유의미하게 감소했고,
인증 경로 DB 조회를 제거해 MySQL 피크 CPU도 완화했습니다.
핵심은 성능 개선뿐 아니라 키 규칙/TTL/포맷을 팀 표준으로 만든 점입니다.

### 핵심 키워드(압축)

- 병목 식별: 인증 경로 DB read 집중
- 설계 전환: RDB -> Redis(TTL KV)
- 안정화 포인트: key schema / TTL / serialization
- 성과 지표: avg, p95, DB CPU, DB query count
- 운영 관점: 정책 명시(single-session), 장애 시 재로그인 폴백

## 부록 B. 발표형 답변 (스토리텔링 중심)

### 30초 버전

처음엔 "토큰은 DB에 저장하면 안전하다"고 생각했습니다.
기능은 잘 됐지만, 등원 시간대에 로그인/재발급이 몰리면 인증이 전체 체감을 늦췄습니다.
그래서 Redis를 붙였는데, 처음엔 오히려 키 설계와 TTL 실수로 더 흔들렸습니다.
그 과정을 통해 규칙을 정리했고, 결국 재발급 응답시간과 피크 지연을 크게 낮췄습니다.

### 1분 30초 버전

이 경험의 시작은 "왜 서비스가 가끔만 느려질까"였습니다.
비즈니스 API는 빠른데, 특정 시간대에만 지연이 튀었습니다.
추적해 보니 원인은 인증 경로였습니다.
Refresh token을 DB에서 읽고 검증하는 작업이 누적되면서,
사용자 입장에서는 화면이 늦게 뜨는 것으로 체감됐습니다.

그래서 Redis로 옮겼지만 첫 시도는 완벽하지 않았습니다.
키를 패턴으로 조회하는 구조를 잡아두는 바람에 키가 늘수록 비효율이 커졌고,
일부 경로에서 TTL이 빠져 "만료돼야 할 토큰"이 남아 있었습니다.
직렬화 포맷도 통일되지 않아 간헐 예외가 났습니다.

이때 접근을 바꿨습니다.
성능 최적화가 아니라 "운영 규칙 수립" 문제로 본 겁니다.
키는 `refresh:{email}`로 고정하고,
저장은 `set + TTL` 단일 메서드만 사용하게 제한했습니다.
포맷은 문자열 하나로 통일하고, 통합 테스트로 TTL/삭제/재발급 흐름을 끝까지 검증했습니다.

그 결과 수치는 분명히 좋아졌고(평균/상위 지연 감소),
무엇보다 "왜 빨라졌는지"를 팀이 설명할 수 있게 됐습니다.
제가 얻은 가장 큰 배움은,
Redis의 가치는 기술 도입 자체보다 운영 규칙을 설계하는 능력에서 나온다는 점입니다.

### 발표 마무리 멘트

"저는 성능 개선을 한 번의 트릭으로 보지 않습니다.
측정하고, 실패를 복기하고, 규칙으로 고정해 재발을 막는 과정 자체가 실력이라고 생각합니다."

## 부록 C. 면접 답변 암기용 10문장

### C-1) 기술면접형 10문장

1. 이 프로젝트에서 Redis는 캐시 범용 도입이 아니라 refresh token 경로 병목 해소를 위해 도입했습니다.
2. 도입 전에는 재발급 시 MySQL 조회가 반복되어 인증 경로가 피크 시간대 지연의 원인이 됐습니다.
3. 먼저 동일 시나리오를 고정해 평균 응답시간, p95, DB 조회 수를 전후 비교 지표로 정했습니다.
4. 핵심 설계는 키를 `refresh:{email}` 단일 규칙으로 통일해 조회/삭제를 O(1)로 단순화한 것입니다.
5. 초기에는 패턴 검색 키 설계 때문에 키 수 증가 시 비효율이 발생했고 즉시 구조를 수정했습니다.
6. 두 번째 이슈는 TTL 누락이었고, 저장 API를 `set + TTL` 단일 메서드로 강제해 재발을 막았습니다.
7. 세 번째 이슈는 직렬화 포맷 혼재였고, `StringRedisTemplate` 기반 문자열 저장으로 통일했습니다.
8. 정책 충돌은 single-session 원칙을 명시해 최신 로그인 기준으로 정리했습니다.
9. 결과적으로 재발급 API 평균은 32ms에서 9ms, p95는 78ms에서 21ms로 개선됐습니다.
10. 제가 만든 가치는 성능 수치뿐 아니라 키/TTL/포맷 규칙을 팀 표준으로 정착시킨 점입니다.

### C-2) 발표형 10문장

1. 처음에는 토큰을 DB에 저장하면 안전하고 단순하다고 생각했습니다.
2. 그런데 등원 시간대처럼 로그인 요청이 몰리면 서비스가 가끔 느려졌습니다.
3. 비즈니스 API를 의심했지만, 실제 병목은 인증의 재발급 경로였습니다.
4. 그래서 Redis를 도입했는데, 첫 시도는 키를 패턴으로 조회해 오히려 비효율이 생겼습니다.
5. 또 일부 경로에서 TTL이 빠져 만료돼야 할 토큰이 남는 문제도 겪었습니다.
6. 직렬화 포맷까지 섞여 간헐 예외가 발생하면서, 기술보다 운영 규칙의 중요성을 체감했습니다.
7. 이후 키를 `refresh:{email}`로 고정하고 저장은 `set + TTL`만 허용하도록 구조를 바꿨습니다.
8. 포맷도 문자열 하나로 통일하고 TTL/삭제/재발급 흐름을 통합 테스트로 검증했습니다.
9. 그 결과 응답시간과 상위 지연이 유의미하게 줄고, 피크 시간대 DB 부담도 완화됐습니다.
10. 이 경험을 통해 저는 성능 개선의 본질이 도구 선택이 아니라 규칙 설계와 재발 방지에 있다는 것을 배웠습니다.
