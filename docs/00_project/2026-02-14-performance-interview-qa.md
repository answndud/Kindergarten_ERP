# 2026-02-14 성능 면접 Q&A (한국어)

아래는 실제 면접에서 자주 나오는 흐름 기준으로 구성한 질문/답변 템플릿입니다.
각 질문마다 10초 버전, 30초 버전을 함께 정리했습니다.

## Q1. 이번 프로젝트에서 성능 병목을 어떻게 찾았나요?

- 10초 답변:
  감으로 최적화하지 않고, 같은 시나리오에서 쿼리 수와 응답 시간을 먼저 측정해 병목 구간을 찾았습니다.
- 30초 답변:
  사용자 체감이 큰 알림장 목록과 대시보드 통계를 우선 대상으로 잡았습니다.
  동일 데이터/동일 시나리오에서 전후 비교가 가능하도록 테스트를 만들고,
  쿼리 수와 elapsed time을 같이 기록해서 N+1과 불필요한 집계 경로를 병목으로 확정했습니다.

## Q2. 왜 Notepad를 첫 개선 대상으로 선택했나요?

- 10초 답변:
  목록 조회는 호출 빈도가 높고, N+1이 있으면 데이터가 늘수록 가장 빠르게 느려지기 때문입니다.
- 30초 답변:
  알림장은 학부모/교사가 반복적으로 조회하는 핵심 화면이라 성능 체감이 바로 나타납니다.
  실제로 읽음 수를 건별 조회하는 구조가 있어서 페이지 크기에 비례해 쿼리가 증가했고,
  투자 대비 효과가 가장 큰 구간이라 1순위로 선정했습니다.

## Q3. Notepad N+1은 어떻게 해결했나요?

- 10초 답변:
  건별 읽음 조회를 없애고, 페이지 notepad ID를 모아 집계 쿼리 1회로 readCount를 계산했습니다.
- 30초 답변:
  기존엔 페이지 N건에 대해 `findReadConfirmsByNotepadId`를 반복 호출했습니다.
  이를 `countReadConfirmsByNotepadIds` 집계 쿼리로 전환하고,
  서비스에서 ID별 맵으로 매핑해 DTO를 구성했습니다.
  결과적으로 쿼리 수가 22에서 4로 줄었습니다.

## Q4. 대시보드 통계는 어떤 방식으로 개선했나요?

- 10초 답변:
  목록 로딩 후 계산하던 경로를 집계 쿼리 중심으로 바꿨습니다.
- 30초 답변:
  출석률은 PRESENT/LATE를 각각 count하던 구조를 단일 집계로 통합했고,
  공지 열람률도 공지 목록을 읽어 합산하는 대신 DB에서 `SUM(view_count)`로 계산했습니다.
  이렇게 계산 경로를 단순화해 쿼리 수 13 -> 10, 응답 시간 14ms -> 2ms를 확인했습니다.

## Q5. Redis refresh token 경로를 왜 바꿨나요?

- 10초 답변:
  패턴 키 검색은 운영에서 부담이 커서, `refresh:{email}` 단일 키 O(1) 조회/삭제로 바꿨습니다.
- 30초 답변:
  기존 패턴 검색 방식은 키 수 증가 시 비용과 운영 리스크가 커집니다.
  그래서 키 설계를 단순화해 조회/삭제를 예측 가능한 O(1)로 만들고,
  재발급 시 Redis 저장 토큰과 요청 토큰의 일치 검증까지 추가해 안전성과 성능을 같이 챙겼습니다.

## Q6. 인덱스는 어떤 기준으로 설계했나요?

- 10초 답변:
  실제 `where/order/join` 패턴에 맞춘 복합 인덱스를 설계하고 EXPLAIN으로 검증했습니다.
- 30초 답변:
  코드의 JPQL/SQL 패턴을 먼저 확인한 뒤,
  Notepad/Announcement 목록 정렬, Dashboard 집계 조건에 맞춰 복합 인덱스를 추가했습니다.
  결과적으로 EXPLAIN에서 ALL/filesort가 줄고 ref/range로 전환되는 것을 확인했습니다.

## Q7. 개선 효과를 어떻게 증명했나요?

- 10초 답변:
  전후 동일 시나리오로 쿼리 수와 응답 시간을 비교해 문서에 수치로 남겼습니다.
- 30초 답변:
  테스트 코드에서 성능 비교 경로를 분리해 legacy vs optimized를 같은 조건으로 실행했습니다.
  Notepad는 22 -> 4 쿼리, 15ms -> 4ms,
  Dashboard는 13 -> 10 쿼리, 14ms -> 2ms로 측정했고,
  결과를 문서와 테스트 로그 파일에 함께 기록했습니다.

## Q8. 성능 개선 과정에서 가장 중요하게 본 원칙은?

- 10초 답변:
  캐시보다 먼저 원인을 제거하고, 변경마다 측정 가능한 근거를 남기는 것입니다.
- 30초 답변:
  빠르게 보이는 해결책보다 재현 가능한 개선을 우선했습니다.
  그래서 N+1 제거 -> 집계 통합 -> 인덱스 검증 순서로 진행했고,
  각 단계마다 전후 수치를 남겨서 "왜 개선됐는지"를 설명할 수 있게 만들었습니다.

## Q9. 트레이드오프는 무엇이었나요?

- 10초 답변:
  인덱스 추가로 쓰기 비용과 저장공간은 늘지만, 조회 성능 이득이 더 컸습니다.
- 30초 답변:
  조회가 핵심인 화면에서는 read 최적화 가치가 높아서 인덱스 추가를 선택했습니다.
  대신 인덱스가 많아질수록 쓰기 부담이 생기기 때문에,
  이후에는 slow query log와 실행계획을 기준으로 주기적으로 정리할 계획입니다.

## Q10. 다음 성능 개선 계획은 무엇인가요?

- 10초 답변:
  k6 부하 테스트와 캐시 TTL 전략을 붙여 피크 구간 안정성을 추가로 검증할 계획입니다.
- 30초 답변:
  지금은 단일 요청 기준 최적화가 중심이었고,
  다음 단계는 동시성 구간에서 p95/p99를 검증하는 부하 테스트를 진행하려고 합니다.
  이후 대시보드 통계에 짧은 TTL 캐시를 적용하고,
  캐시 적중률/갱신비용/정합성 트레이드오프까지 수치로 정리할 계획입니다.
